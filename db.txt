create table "public"."events" (
    "id" bigint generated always as identity not null,
    "title" text not null,
	  "location" text not null,
    "date" date not null,
	  "time" time not null,
    "created_at" timestamp with time zone default now(),
    "user_id" uuid not null references auth.users(id)
    );



  create table "public"."notes" (
    "id" bigint generated always as identity not null,
    "title" text not null,
    "note" text not null,
    "date" date not null,
    "created_at" timestamp with time zone default now(),
    "user_id" uuid not null references auth.users(id)
    );



  create table "public"."planners" (
    "id" bigint generated always as identity not null,
    "title" text not null,
    "b_color" text not null default 'white'::text,
    "a_color" text not null default 'black'::text,
    "font" text not null default 'sans-serif'::text
    );



  create table "public"."tasks" (
    "id" bigint generated always as identity not null,
    "title" text not null,
    "task" text not null,
    "date" date not null,
    "done" bool not null default false,
    "created_at" timestamp with time zone default now(),
    "user_id" uuid not null references auth.users(id)
    );




    -- Create 'profiles' table
create table if not exists profiles (
    id uuid references auth.users(id) on delete cascade,
    name text not null,
    bio text,
    avatar text,
    created_at timestamp with time zone default now() not null,
    updated_at timestamp with time zone default now() not null,
    primary key (id)
);

-- Trigger function to update 'updated_at' on row change
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Attach trigger to 'profiles' table
drop trigger if exists set_updated_at on profiles;
create trigger set_updated_at
before update on profiles
for each row
execute function update_updated_at_column();
